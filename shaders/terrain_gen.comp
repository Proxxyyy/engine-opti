#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(r32f, binding = 0) uniform image2D u_heightmap;

uniform vec2 u_camera_pos;
uniform float u_scale;
uniform float u_noise_freq_scale;
uniform float u_height_scale;

// Simple hash function
float hash12(vec2 p) {
    vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

// 2D Noise
float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(mix(hash12(i + vec2(0.0, 0.0)),
                   hash12(i + vec2(1.0, 0.0)), u.x),
               mix(hash12(i + vec2(0.0, 1.0)),
                   hash12(i + vec2(1.0, 1.0)), u.x), u.y);
}

// Fractal Brownian Motion
float fbm(vec2 x) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
    for (int i = 0; i < 5; ++i) {
        v += a * noise(x);
        x = rot * x * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(u_heightmap);

    if (texel.x >= size.x || texel.y >= size.y) {
        return;
    }

    // Map texel to UV [-0.5, 0.5] from center of map
    vec2 uv = (vec2(texel) / vec2(size)) - 0.5;

    // World XZ position derivation
    // u_scale is "how many meters does the heightmap cover"
    vec2 world_pos = u_camera_pos + uv * u_scale;

    // Generate height
    float height = fbm(world_pos * u_noise_freq_scale) * u_height_scale;

    imageStore(u_heightmap, texel, vec4(height, 0.0, 0.0, 1.0));
}
